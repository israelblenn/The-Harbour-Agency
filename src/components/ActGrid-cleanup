'use client'

import { useEffect, useState, useRef, useLayoutEffect, useMemo, useCallback } from 'react'
import { motion, LayoutGroup, animate } from 'framer-motion'
import { useSelectedAct } from '@/contexts/SelectedActContext'
import Image from 'next/image'
import styles from '@/styles/ActGrid.module.css'

type Act = { id: string; name: string; photo: { url: string } }

const PAGE_SIZE = 20
const GAP = 16
const MIN_ITEM_WIDTH = 170
const SPAN = 3
const OVERSCAN = 300
const SPRING = {
  type: 'spring' as const,
  stiffness: 150,
  damping: 25,
}

export default function ActImageGrid() {
  const [acts, setActs] = useState<Act[]>([])
  const [pageNum, setPageNum] = useState(1)
  const [hasNextPage, setHasNextPage] = useState(true)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [containerWidth, setContainerWidth] = useState(0)
  const { selectedActId, setSelectedActId } = useSelectedAct()
  const containerRef = useRef<HTMLDivElement>(null)

  // Effect for fetching data
  useEffect(() => {
    const abortController = new AbortController()

    const fetchData = async () => {
      setLoading(true)
      setError(null)
      try {
        const res = await fetch(
          `${process.env.NEXT_PUBLIC_SITE_URL}/api/acts?limit=${PAGE_SIZE}&page=${pageNum}&sort=name`,
          { signal: abortController.signal },
        )
        if (!res.ok) throw new Error(res.statusText)
        const data = await res.json()
        setActs((prev) => [...prev, ...data.docs])
        setHasNextPage(data.hasNextPage)
      } catch (e) {
        if ((e as Error).name !== 'AbortError') setError((e as Error).message)
      } finally {
        if (!abortController.signal.aborted) setLoading(false)
      }
    }

    fetchData()
    return () => abortController.abort()
  }, [pageNum])

  // Effect for observing container resize
  useLayoutEffect(() => {
    if (!containerRef.current) return
    const observer = new ResizeObserver(([entry]) => setContainerWidth(entry.contentRect.width))
    observer.observe(containerRef.current)
    return () => observer.disconnect()
  }, [])

  // Calculate number of columns and cell size based on container width
  const { numColumns, cellSize } = useMemo(() => {
    if (containerWidth === 0) return { numColumns: 0, cellSize: 0 }
    const numCols = Math.max(1, Math.floor((containerWidth + GAP) / (MIN_ITEM_WIDTH + GAP)))
    const size = (containerWidth - GAP * (numCols - 1)) / numCols
    return { numColumns: numCols, cellSize: size }
  }, [containerWidth])
  const layoutReady = numColumns > 0 && cellSize > 0 // Flag indicating layout can be rendered

  // Calculate positions for each act in the grid
  const positions = useMemo(() => {
    if (!layoutReady) return []
    const maxSpan = Math.min(SPAN, numColumns)
    const positions: { x: number; y: number; w: number; h: number }[] = []
    const grid: boolean[][] = []

    const isOccupied = (x: number, y: number) => grid[y]?.[x] ?? false
    const occupy = (x: number, y: number) => {
      if (!grid[y]) grid[y] = []
      grid[y][x] = true
    }

    // Placement algorithm for each act
    for (let i = 0; i < acts.length; i++) {
      const act = acts[i]
      const isSel = act.id === selectedActId
      const span = isSel ? maxSpan : 1
      let placed = false
      let row = 0

      while (!placed) {
        for (let col = 0; col <= numColumns - span; col++) {
          let free = true
          for (let dx = 0; dx < span; dx++) {
            for (let dy = 0; dy < span; dy++) {
              if (isOccupied(col + dx, row + dy)) {
                free = false
                break
              }
            }
            if (!free) break
          }
          if (!free) continue

          for (let dx = 0; dx < span; dx++) {
            for (let dy = 0; dy < span; dy++) {
              occupy(col + dx, row + dy)
            }
          }

          positions.push({ x: col, y: row, w: span, h: span })
          placed = true
          break
        }
        if (!placed) row++
      }
    }

    return positions
  }, [acts, selectedActId, numColumns, layoutReady])

  // Scroll handler for infinite loading
  const handleScroll = useCallback(() => {
    if (!containerRef.current || loading || !hasNextPage) return
    const { scrollTop, clientHeight, scrollHeight } = containerRef.current
    if (scrollTop + clientHeight >= scrollHeight - OVERSCAN) setPageNum((prev) => prev + 1)
  }, [loading, hasNextPage])

  // Effect to add/remove scroll listener
  useEffect(() => {
    const container = containerRef.current
    if (!container) return
    container.addEventListener('scroll', handleScroll)
    return () => container.removeEventListener('scroll', handleScroll)
  }, [handleScroll])

  // Effect to scroll to selected act
  useEffect(() => {
    if (!selectedActId || !containerRef.current) return
    const index = acts.findIndex((a) => a.id === selectedActId)
    if (index === -1 || index >= positions.length) return

    const { y } = positions[index]
    const rowHeight = cellSize + GAP
    const itemTop = y * rowHeight

    animate(containerRef.current.scrollTop, itemTop, {
      ...SPRING,
      onUpdate: (value) => (containerRef.current!.scrollTop = value),
    })
  }, [selectedActId, acts, positions, cellSize])

  return (
    <div>
      <div ref={containerRef} className={`scrollable ${styles.container}`}>
        <LayoutGroup>
          {layoutReady && (
            <div style={{ display: 'grid', gridAutoRows: cellSize, gap: GAP }}>
              {acts.map((act, i) => {
                const pos = positions[i]
                if (!pos) return null

                return (
                  <motion.div
                    key={act.id}
                    onClick={() => setSelectedActId(act.id)}
                    transition={SPRING}
                    layout
                    className={styles.cell}
                    style={{
                      gridColumnStart: pos.x + 1,
                      gridColumnEnd: `span ${pos.w}`,
                      gridRowStart: pos.y + 1,
                      gridRowEnd: `span ${pos.h}`,
                    }}
                  >
                    <Image src={act.photo.url} alt={act.name} fill sizes={`${Math.round(cellSize * pos.w)}px`} />
                  </motion.div>
                )
              })}
            </div>
          )}
        </LayoutGroup>
      </div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
    </div>
  )
}
